#!/usr/bin/env python
# vim: set filetype=python

"""
Upstanding Server Management Support Tools

See README.md for more information.
"""


import os
import subprocess
import sys


# check for and set up development path
_pwd = os.path.dirname( os.path.realpath( __file__ ) )
_modules_path = os.path.join( os.path.dirname( _pwd ), 'up' )
if os.path.exists( _modules_path ):
    sys.path.append( _modules_path )

# up module imports
import conf


__version__ = '0.0.0'

#=============================================================================
# Module Variables

_rsync       = '/usr/local/bin/rsync'
_rsync_flags = [ '-avz', '--delete' ]


#=============================================================================
def backup( args ):
    """
    Executes configured backups.

    @param args The argparse argument object
    @return     Shell exit status (0 on success)
    """

    # set basic backup command arguments
    arguments = [ _rsync ] + _rsync_flags

    # check for a test command
    if args.test == True:

        # load the test configuration file without validation
        cfile  = os.path.join( os.path.dirname( _pwd ), 'data', 'up.conf' )
        config = conf.load_conf( cfile, validate = False )
        paths  = config[ 'back' ][ 'paths' ]

        # display the commands that would be run for each backup
        for pair in paths:
            sync_args = arguments + pair
            print( subprocess.list2cmdline( sync_args ) )

    # not a test command
    else:

        # load system configuration file
        try:
            config = conf.load_conf()
        except conf.FileError:
            print(
                'Configuration file not found at {}'.format(
                    conf.confpath
                )
            )
            return 1
        except conf.ParseError:
            print( 'Unable to parse configuration file.' )
            return 1
        except conf.ValidError as ve:
            print( 'Configuration validity check failed: {}'.format( ve ) )
            return 1

        # configuration loaded successfully
        else:

            # iterate through each backup pair
            paths = config[ 'back' ][ 'paths' ]
            for pair in paths:

                # set the list of arguments for this rsync run
                sync_args = arguments + pair

                # setup and execute rsync for this source-target pair
                try:
                    proc = subprocess.Popen(
                        arguments,
                        stdout = subprocess.PIPE,
                        stderr = subprocess.STDOUT
                    )
                    output, errors = proc.communicate()

                # error encountered
                except subprocess.CalledProcessError as error:
                    print(
                        'Error executing rsync: {}'.format( error.output )
                    )
                    return 1

                # rsync finished with a 0 status
                else:

                    # ZIH - temp code, make this log to a file or something
                    print '--- EXECUTED ---'
                    print subprocess.list2cmdline( sync_args )
                    print '--- OUTPUT ---'
                    print output
                    print '--- ERRORS ---'
                    print errors

    # indicate the backup was executed successfully
    return 0


#=============================================================================
def situp( args ):
    """
    Executes configured updates.

    @param args The argparse argument object
    @return     Shell exit status (0 on success)
    """

    ### ZIH

    return 0


#=============================================================================
def main( argv ):
    """
    Script execution entry point

    @param argv List of arguments passed to the script
    @return     Shell exit code (0 = success)
    """

    # imports when using this as a script
    import argparse

    # create and configure an argument parser
    parser = argparse.ArgumentParser(
        description = 'Upstanding Server Management Support Tools',
        add_help    = False
    )

    # typical help argument setup
    helpargs   = [ '-h', '--help' ]
    helpkwargs = {
        'default' : False,
        'help'    : 'Display this help message and exit.',
        'action'  : 'help'
    }

    # set up the root argument parser
    parser.add_argument( *helpargs, **helpkwargs )
    parser.add_argument(
        '-v',
        '--version',
        default = False,
        help    = 'Display script version and exit.',
        action  = 'version',
        version = __version__
    )
    parser.add_argument(
        '-t',
        '--test',
        default = False,
        help    = 'Execute inline tests.',
        action  = 'store_true'
    )

    # configure sub-command parsing
    subparsers = parser.add_subparsers(
        title = 'Tools',
        help  = 'The following tools are available.'
    )

    # set up the `back` command parser
    back_command = subparsers.add_parser(
        'back',
        description = 'Execute configured backups.',
        help        = 'Execute configured backups.',
        add_help    = False
    )
    back_command.add_argument( *helpargs, **helpkwargs )
    back_command.add_argument(
        '-t',
        '--test',
        default = False,
        help    = 'Runs a "test" backup without synchronizing any files.',
        action  = 'store_true'
    )
    back_command.set_defaults( call = backup )

    # set up the `sit` command parser
    sit_command = subparsers.add_parser(
        'sit',
        description = 'Report configured statuses.',
        help        = 'Report configured statuses.',
        add_help    = False
    )
    sit_command.add_argument( *helpargs, **helpkwargs )
    sit_command.set_defaults( call = situp )

    # parse the arguments
    args = parser.parse_args( argv[ 1 : ] )

    # call the appropriate, arguments-aware function
    result = args.call( args )

    # return result of command
    return result


#=============================================================================
if __name__ == "__main__":
    sys.exit( main( sys.argv ) )

